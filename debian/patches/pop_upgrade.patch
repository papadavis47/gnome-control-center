Index: gnome-control-center/panels/info/cc-info-overview-panel.c
===================================================================
--- gnome-control-center.orig/panels/info/cc-info-overview-panel.c
+++ gnome-control-center/panels/info/cc-info-overview-panel.c
@@ -49,6 +49,7 @@
 #include "cc-info-overview-panel.h"
 #include "dmi-info.h"
 #include "gsd-disk-space-helper.h"
+#include "pop-upgrade.h"
 #include "s76-firmware.h"
 #include <polkit/polkit.h>
 
@@ -80,6 +81,7 @@ typedef struct
   GtkWidget      *firmware_button;
   GtkWidget      *lock_button;
   GtkWidget      *lock_header;
+  GtkWidget      *os_upgrade_frame;
   GPermission    *permission;
 
   S76FirmwareDaemon  *firmware_daemon;
@@ -87,6 +89,13 @@ typedef struct
   gchar              *firmware_digest;
   gchar              *firmware_changelog;
 
+  gpointer            pop_conn_data;
+  PopUpgradeWidgets   pop_upgrade;
+  PopUpgradeDaemon   *upgrade_daemon;
+  ReleaseCheck       *release_check;
+  guint               os_subscribe;
+  guint               os_subscribe_idle;
+
   /* Virtualisation labels */
   GtkWidget      *label8;
   GtkWidget      *grid1;
@@ -862,13 +871,43 @@ cc_info_overview_panel_constructed (GObj
 }
 
 static void
+pop_upgrade_stop_listening (CcInfoOverviewPanelPrivate *self,
+                            GDBusConnection *connection)
+{
+  g_info ("refusing to listen to the pop-upgrade daemon any further");
+  if (self != NULL && 0 != self->os_subscribe) {
+    g_dbus_connection_signal_unsubscribe (connection, self->os_subscribe);
+    self->os_subscribe = 0;
+  }
+}
+
+typedef struct {
+  PopUpgradeOption *active;
+  CcInfoOverviewPanelPrivate *priv;
+  guint expected_status;
+} ConnectionData;
+
+static void
 cc_info_overview_panel_dispose (GObject *object)
 {
   CcInfoOverviewPanelPrivate *priv = cc_info_overview_panel_get_instance_private (CC_INFO_OVERVIEW_PANEL (object));
 
+  if (0 != priv->os_subscribe_idle) {
+    g_source_remove (priv->os_subscribe_idle);
+    g_slice_free (ConnectionData, priv->pop_conn_data);
+  }
+
+  if (0 != priv->os_subscribe) {
+    PopUpgradeDaemon *daemon = priv->upgrade_daemon;
+    GDBusConnection *conn = g_dbus_proxy_get_connection (daemon->proxy);
+    pop_upgrade_stop_listening (priv, conn);
+  }
+
   g_clear_pointer (&priv->graphics_data, graphics_data_free);
   g_clear_pointer (&priv->firmware_version, s76_firmware_version_free);
+  g_clear_pointer (&priv->release_check, release_check_free);
   g_slice_free (S76FirmwareDaemon, priv->firmware_daemon);
+  g_slice_free (PopUpgradeDaemon, priv->upgrade_daemon);
   g_clear_object (&priv->permission);
 
   G_OBJECT_CLASS (cc_info_overview_panel_parent_class)->dispose (object);
@@ -960,6 +999,300 @@ s76_firmware_dialog (GtkButton *button,
 }
 
 static void
+pop_upgrade_other_options (CcInfoOverviewPanelPrivate *self,
+                           PopUpgradeOption *other_options[2])
+{
+  other_options[0] = (self->pop_upgrade.os.active)
+    ? &self->pop_upgrade.rec
+    : &self->pop_upgrade.os;
+}
+
+static void
+pop_upgrade_failed (PopUpgradeOption *active,
+                    CcInfoOverviewPanelPrivate *self,
+                    GDBusConnection *connection,
+                    const gchar *why)
+{
+  g_info ("pop_upgrade: upgrade failed: %s", why);
+  pop_upgrade_stop_listening (self, connection);
+
+  PopUpgradeOption *other_options[2] = { NULL, NULL };
+  pop_upgrade_other_options (self, other_options);
+  pop_upgrade_option_try_again (active, other_options, why);
+}
+
+static gboolean
+pop_upgrade_event_result (PopUpgradeOption *active, CcInfoOverviewPanelPrivate *self,
+                          GDBusConnection *connection, GVariant *parameters,
+                          const gchar *ok, const gchar *err)
+{
+  g_info ("pop_upgrade: processing result");
+  g_autoptr(GVariant) inner = g_variant_get_child_value (parameters, 0);
+  guint8 result = g_variant_get_byte (inner);
+  if (0 == result) {
+    gtk_progress_bar_set_text (GTK_PROGRESS_BAR (active->progress), ok);
+    return TRUE;
+  } else {
+    pop_upgrade_failed (active, self, connection, err);
+    return FALSE;
+  }
+}
+
+static void
+pop_upgrade_signal_success (CcInfoOverviewPanelPrivate *self,
+                            GDBusConnection *connection,
+                            PopUpgradeOption *active,
+                            const gchar *msg)
+{
+  g_info ("pop-upgrade signaled success: %s", msg);
+  active->actionable = FALSE;
+  gtk_label_set_text (GTK_LABEL (active->label), msg);
+  gtk_stack_set_visible_child (GTK_STACK (active->stack), active->button_box);
+
+  PopUpgradeOption *other_options[2] = { NULL, NULL };
+  pop_upgrade_other_options (self, other_options);
+  pop_upgrade_option_reset_options (other_options);
+  pop_upgrade_stop_listening (self, connection);
+}
+
+static void
+pop_upgrade_event_listen (GDBusConnection            *connection,
+                          const gchar                *sender_name,
+                          const gchar                *object_path,
+                          const gchar                *interface_name,
+                          const gchar                *signal_name,
+                          GVariant                   *parameters,
+                          CcInfoOverviewPanelPrivate *self)
+{
+  g_info ("received upgrade signal:\n \
+    \tsignal_name: %s\n \
+    \tinterface_name: %s\n \
+    \tsender_name: %s\n \
+    \tobject_path: %s\n", signal_name, interface_name, sender_name, object_path);
+
+  g_info ("variant type returned: %s", g_variant_get_type_string (parameters));
+
+  if (self->pop_upgrade.os.active) {
+    PopUpgradeOption *active = &self->pop_upgrade.os;
+
+    if (0 == g_strcmp0 (POP_UPGRADE_SIGNAL_PACKAGE_FETCHED, signal_name)) {
+      pop_upgrade_package_fetched (active, parameters);
+    } else if (0 == g_strcmp0 (POP_UPGRADE_SIGNAL_PACKAGE_FETCHING, signal_name)) {
+      pop_upgrade_package_fetching (active, parameters);
+    } else if (0 == g_strcmp0 (POP_UPGRADE_SIGNAL_PACKAGE_UPGRADE, signal_name)) {
+      pop_upgrade_package_upgrade (active, parameters);
+    } else if (0 == g_strcmp0 (POP_UPGRADE_SIGNAL_PACKAGE_FETCH_RESULT, signal_name)) {
+      pop_upgrade_event_result (active, self, connection, parameters,
+                                _("Packages fetched successfully"),
+                                _("Failed to fetch package"));
+    } else if (0 == g_strcmp0 (POP_UPGRADE_SIGNAL_RECOVERY_RESULT, signal_name)) {
+      pop_upgrade_event_result (active, self, connection, parameters,
+                                _("Recovery partition upgraded"),
+                                _("Failed to upgrade recovery partition"));
+    } else if (0 == g_strcmp0 (POP_UPGRADE_SIGNAL_RELEASE_EVENT, signal_name)) {
+      pop_upgrade_event_event (active, parameters, pop_upgrade_release_event_as_str);
+    } else if (0 == g_strcmp0 (POP_UPGRADE_SIGNAL_RELEASE_RESULT, signal_name)) {
+      const gchar *msg = _("Release ready. You may now restart.");
+      gboolean success = pop_upgrade_event_result (active, self, connection, parameters,
+                                                   msg, _("Failed to set up release upgrade"));
+
+      if (success) {
+        pop_upgrade_signal_success (self, connection, active, msg);
+      }
+    }
+  } else {
+    PopUpgradeOption *active = &self->pop_upgrade.rec;
+
+    if (0 == g_strcmp0 (POP_UPGRADE_SIGNAL_RECOVERY_DOWNLOAD_PROGRESS, signal_name)) {
+      pop_upgrade_recovery_download_progress (active, parameters);
+    } else if (0 == g_strcmp0 (POP_UPGRADE_SIGNAL_RECOVERY_EVENT, signal_name)) {
+      pop_upgrade_event_event (active, parameters, pop_upgrade_recovery_event_as_str);
+    } else if (0 == g_strcmp0 (POP_UPGRADE_SIGNAL_RECOVERY_RESULT, signal_name)) {
+      const gchar *msg = _("Recovery partition upgraded");
+      gboolean success = pop_upgrade_event_result (active, self, connection, parameters,
+                                                   msg, _("Failed to set up recovery upgrade"));
+
+      if (success) {
+        pop_upgrade_signal_success (self, connection, active, msg);
+      }
+    }
+  }
+}
+
+static gboolean
+pop_upgrade_check (ConnectionData *data)
+{
+  if (0 != data->priv->os_subscribe) {
+    PopUpgradeDaemon *daemon = data->priv->upgrade_daemon;
+    PopUpgradeDaemonStatus status = pop_upgrade_daemon_status_new ();
+    char *cause = "failed to fetch status from upgrade daemon";
+
+    if (0 == pop_upgrade_daemon_status (daemon, NULL, &status)) {
+      if (status.status == data->expected_status) {
+        return TRUE;
+      } else {
+        cause = "Daemon status changed before result was received";
+      }
+    }
+
+    pop_upgrade_failed (data->active, data->priv,
+                        g_dbus_proxy_get_connection (daemon->proxy),
+                        cause);
+  }
+
+  data->priv->os_subscribe_idle = 0;
+  g_slice_free (ConnectionData, data);
+  return FALSE;
+}
+
+static void
+pop_upgrade_daemon_listen (PopUpgradeOption *active, CcInfoOverviewPanelPrivate *self,
+                           guint expected_status)
+{
+    PopUpgradeDaemon *daemon = self->upgrade_daemon;
+    GDBusConnection *conn = g_dbus_proxy_get_connection (daemon->proxy);
+    self->os_subscribe = g_dbus_connection_signal_subscribe (
+      conn,
+      POP_UPGRADE_BUS_NAME,
+      POP_UPGRADE_INTERFACE_NAME,
+      NULL,
+      POP_UPGRADE_OBJECT_PATH,
+      NULL,
+      G_DBUS_SIGNAL_FLAGS_NONE,
+      pop_upgrade_event_listen,
+      self,
+      NULL
+    );
+
+    ConnectionData *data = g_slice_new0 (ConnectionData);
+    data->active = active;
+    data->priv = self;
+    data->expected_status = expected_status;
+    self->os_subscribe_idle = g_timeout_add (3000, pop_upgrade_check, data);
+    self->pop_conn_data = data;
+}
+
+static void
+pop_upgrade_daemon_listen_upgrade_signals (CcInfoOverviewPanelPrivate *self)
+{
+  pop_upgrade_daemon_listen (&self->pop_upgrade.os, self, POP_UPGRADE_STATUS_RELEASE_UPGRADE);
+}
+
+static void
+pop_upgrade_daemon_listen_recovery_upgrade_signals (CcInfoOverviewPanelPrivate *self)
+{
+  pop_upgrade_daemon_listen (&self->pop_upgrade.rec, self, POP_UPGRADE_STATUS_RECOVERY_UPGRADE);
+}
+
+static void
+pop_upgrade_recovery (CcInfoOverviewPanelPrivate *priv, GError **error, gchar **error_message) {
+  pop_upgrade_daemon_listen_recovery_upgrade_signals (priv);
+  int result = pop_upgrade_daemon_recovery_upgrade_by_release (priv->upgrade_daemon, error,
+                                                               priv->release_check->next,
+                                                               pop_upgrade_get_channel (),
+                                                               0);
+
+  if (0 != result) {
+    *error_message = g_strdup_printf (_("Failed to start recovery upgrade: %s"), (*error)->message);
+  }
+}
+
+static void
+pop_recovery_upgrade (GtkButton *button,
+                      CcInfoOverviewPanel *self)
+{
+  g_info ("Pop upgrade process starting");
+  CcInfoOverviewPanelPrivate *priv = cc_info_overview_panel_get_instance_private (self);
+
+  PopUpgradeOption *other_options[2] = { &priv->pop_upgrade.os, NULL };
+  pop_upgrade_option_initiate_action (
+    &priv->pop_upgrade.rec,
+    other_options,
+    _("Initializing recovery upgrade"),
+    _("Recovery upgrade in progress -- please wait")
+  );
+
+  g_info ("upgrading from %s to %s", priv->release_check->current,
+           priv->release_check->next);
+
+  g_autoptr(GError) error = NULL;
+  g_autofree gchar *error_message = NULL;
+
+  // Ensure that the /recovery partition is mounted, if it can be mounted.
+  // The daemon will safely fix other system isues as well, if it finds any.
+  if (0 == pop_upgrade_daemon_repair (priv->upgrade_daemon, &error)) {
+    pop_upgrade_recovery (priv, &error, &error_message);
+  } else {
+    error_message = g_strdup_printf (_("Failed to repair system: %s"), error->message);
+  }
+
+  if (NULL != error_message) {
+    pop_upgrade_option_try_again (&priv->pop_upgrade.rec, other_options, error_message);
+  }
+}
+
+static void
+pop_upgrade (GtkButton *button,
+             CcInfoOverviewPanel *self)
+{
+  g_info ("Pop upgrade process starting");
+  CcInfoOverviewPanelPrivate *priv = cc_info_overview_panel_get_instance_private (self);
+
+  PopUpgradeOption *other_options[2] = { &priv->pop_upgrade.rec, NULL };
+  pop_upgrade_option_initiate_action (
+    &priv->pop_upgrade.os,
+    other_options,
+    _("Initializing release upgrade"),
+    _("Release upgrade in progress -- please wait")
+  );
+
+  g_info ("upgrading from %s to %s", priv->release_check->current,
+          priv->release_check->next);
+
+  g_autoptr(GError) error = NULL;
+  g_autofree gchar *error_message = NULL;
+
+  // Ensure that the /recovery partition is mounted, if it can be mounted.
+  // The daemon will safely fix other system isues as well, if it finds any.
+  if (0 == pop_upgrade_daemon_repair (priv->upgrade_daemon, &error)) {
+    guint8 method = POP_UPGRADE_RELEASE_METHOD_OFFLINE;
+    if (pop_upgrade_recovery_partition_exists ()) {
+      if (pop_upgrade_recovery_partition_requires_upgrade (priv->release_check)) {
+        GtkWidget *dialog = pop_upgrade_recovery_partition_dialog ();
+        if (GTK_RESPONSE_OK == gtk_dialog_run (GTK_DIALOG (dialog))) {
+          pop_upgrade_option_reset_options (other_options);
+          gtk_stack_set_visible_child (
+            GTK_STACK (priv->pop_upgrade.os.stack),
+            priv->pop_upgrade.os.button_box
+          );
+          pop_recovery_upgrade (button, self);
+        }
+
+        gtk_widget_destroy (dialog);
+        return;
+      }
+
+      method = POP_UPGRADE_RELEASE_METHOD_RECOVERY;
+    }
+
+    pop_upgrade_daemon_listen_upgrade_signals (priv);
+    int result = pop_upgrade_daemon_release_upgrade (priv->upgrade_daemon, &error, method,
+                                        priv->release_check->current,
+                                        priv->release_check->next);
+
+    if (0 != result) {
+      error_message = g_strdup_printf (_("Failed to start release upgrade: %s"), error->message);
+    }
+  } else {
+    error_message = g_strdup_printf (_("Failed to repair system: %s"), error->message);
+  }
+
+  if (NULL != error_message) {
+    pop_upgrade_option_try_again (&priv->pop_upgrade.os, other_options, error_message);
+  }
+}
+
+static void
 cc_info_overview_panel_class_init (CcInfoOverviewPanelClass *klass)
 {
   GObjectClass *object_class = G_OBJECT_CLASS (klass);
@@ -994,21 +1327,30 @@ cc_info_overview_panel_class_init (CcInf
   gtk_widget_class_bind_template_child_private (widget_class, CcInfoOverviewPanel, firmware_upgrade_label);
   gtk_widget_class_bind_template_child_private (widget_class, CcInfoOverviewPanel, firmware_button);
 
+  // Pop!_OS OS upgrade
+  gtk_widget_class_bind_template_child_private (widget_class, CcInfoOverviewPanel, os_upgrade_frame);
+
   g_type_ensure (CC_TYPE_HOSTNAME_ENTRY);
 }
 
 static void
-on_permission_changed (GPermission *permission, GParamSpec *pspec, gpointer data) {
-  CcInfoOverviewPanelPrivate *self = data;
+about_unlock_check (CcInfoOverviewPanelPrivate *self) {
   gboolean is_allowed = g_permission_get_allowed (G_PERMISSION (self->permission));
   gtk_widget_set_sensitive (GTK_WIDGET (self->firmware_button), is_allowed);
+  gtk_widget_set_sensitive (GTK_WIDGET (self->pop_upgrade.os.button), is_allowed);
+  gtk_widget_set_sensitive (GTK_WIDGET (self->pop_upgrade.rec.button), is_allowed);
+}
+
+static void
+on_permission_changed (GPermission *permission, GParamSpec *pspec, gpointer data) {
+  about_unlock_check (data);
 }
 
 static void
 set_permissions (CcInfoOverviewPanelPrivate *self) {
-  GError *error = NULL;
+  g_autoptr(GError) error = NULL;
   self->permission = (GPermission *) polkit_permission_new_sync (INFO_PERMISSION, NULL, NULL, &error);
-  gtk_widget_set_sensitive (self->firmware_button, FALSE);
+  about_unlock_check (self);
 
   if (self->permission != NULL) {
           g_signal_connect (self->permission, "notify",
@@ -1016,18 +1358,62 @@ set_permissions (CcInfoOverviewPanelPriv
           on_permission_changed (self->permission, NULL, self);
   } else {
           g_warning ("Cannot create '%s' permission: %s", INFO_PERMISSION, error->message);
-          g_error_free (error);
   }
 
   self->lock_button = gtk_lock_button_new (self->permission);
   gtk_widget_set_name (self->lock_button, "info-lock");
 
   self->lock_header = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 6);
-  gtk_container_add (self->lock_header, self->lock_button);
+  gtk_container_add (GTK_CONTAINER (self->lock_header), self->lock_button);
   gtk_widget_show_all (self->lock_header);
 }
 
 static void
+connect_upgrade_daemon (CcInfoOverviewPanelPrivate *priv)
+{
+  g_info ("connecting to Pop upgrade daemon");
+
+  const gchar *recovery_text = _("No recovery updates available");
+  const gchar *upgrade_text = _("No upgrades available");
+
+  g_autofree gchar *upgrade_text_heap = NULL;
+  g_autoptr(GError) error = NULL;
+
+  gtk_widget_hide (priv->pop_upgrade.os.button);
+  gtk_widget_hide (priv->pop_upgrade.rec.stack);
+  if (!pop_upgrade_daemon_connect (priv->upgrade_daemon, &error)) {
+    if (!pop_upgrade_daemon_release_check (priv->upgrade_daemon, &error, priv->release_check)) {
+      if (priv->release_check->build > 0) {
+        g_info ("upgrade from %s to %s is available\n", priv->release_check->current,
+                priv->release_check->next);
+
+        // Allow upgrading the recovery partition if the recovery partition exists.
+        if (pop_upgrade_recovery_partition_exists ()) {
+          g_info ("recovery partition exists");
+          recovery_text = _("Recovery update available");
+          gtk_button_set_label (GTK_BUTTON (priv->pop_upgrade.rec.button), _("Upgrade"));
+          gtk_widget_show (priv->pop_upgrade.rec.stack);
+        }
+
+        upgrade_text_heap = g_strdup_printf (
+          _("Upgrade from %s to %s"),
+          priv->release_check->current,
+          priv->release_check->next
+        );
+
+
+        gtk_button_set_label (GTK_BUTTON (priv->pop_upgrade.os.button), _("Upgrade"));
+        gtk_widget_show (priv->pop_upgrade.os.button);
+      }
+    }
+  }
+
+  upgrade_text = (NULL == upgrade_text_heap) ? upgrade_text : upgrade_text_heap;
+  gtk_label_set_text (GTK_LABEL (priv->pop_upgrade.rec.label), recovery_text);
+  gtk_label_set_text (GTK_LABEL (priv->pop_upgrade.os.label), upgrade_text);
+}
+
+static void
 cc_info_overview_panel_init (CcInfoOverviewPanel *self)
 {
   CcInfoOverviewPanelPrivate *priv = cc_info_overview_panel_get_instance_private (self);
@@ -1047,8 +1433,11 @@ cc_info_overview_panel_init (CcInfoOverv
   info_overview_panel_setup_virt (self);
 
   // Pop-specific details
+  priv->pop_upgrade = pop_upgrade_frame (GTK_FRAME (priv->os_upgrade_frame));
   GtkSizeGroup *button_group = gtk_size_group_new (GTK_SIZE_GROUP_HORIZONTAL);
   gtk_size_group_add_widget (button_group, priv->firmware_button);
+  gtk_size_group_add_widget (button_group, priv->pop_upgrade.os.button);
+  gtk_size_group_add_widget (button_group, priv->pop_upgrade.rec.button);
 
   set_computer_label (GTK_LABEL (priv->computer_label));
   set_model_label (GTK_LABEL (priv->model_label));
@@ -1062,9 +1451,18 @@ cc_info_overview_panel_init (CcInfoOverv
     &priv->firmware_changelog
   );
 
+  priv->upgrade_daemon = g_slice_new0 (PopUpgradeDaemon);
+  priv->release_check = g_slice_new0 (ReleaseCheck);
+
+  connect_upgrade_daemon (priv);
+
   set_permissions (priv);
 
   g_signal_connect (priv->firmware_button, "clicked", G_CALLBACK (s76_firmware_dialog), self);
+  g_signal_connect (priv->pop_upgrade.os.button, "clicked", G_CALLBACK (pop_upgrade), self);
+  g_signal_connect (priv->pop_upgrade.rec.button, "clicked", G_CALLBACK (pop_recovery_upgrade), self);
+
+  g_object_unref (button_group);
 }
 
 GtkWidget *
Index: gnome-control-center/panels/info/info-overview.ui
===================================================================
--- gnome-control-center.orig/panels/info/info-overview.ui
+++ gnome-control-center/panels/info/info-overview.ui
@@ -366,6 +366,30 @@
           </packing>
         </child>
         <!-- Pop!_OS-specific UI widgets -->
+        <!-- OS Upgrade Option -->
+        <child>
+          <object class="GtkLabel" id="os_upgrade">
+            <property name="halign">start</property>
+            <property name="use-markup">True</property>
+            <property name="visible">True</property>
+            <property name="margin-top">12</property>
+            <property name="label" translatable="yes">&lt;b&gt;OS Upgrade &#038;amp; Refresh&lt;/b&gt;</property>
+          </object>
+          <packing>
+            <property name="expand">True</property>
+            <property name="fill">True</property>
+            <property name="position">5</property>
+          </packing>
+        </child>
+        <child>
+          <object class="GtkFrame" id="os_upgrade_frame">
+            <property name="visible">True</property>
+            <property name="can_focus">False</property>
+            <property name="label_xalign">0</property>
+            <property name="shadow_type">in</property>
+            <property name="margin_top">6</property>
+          </object>
+        </child>
         <!-- Firmware Option -->
         <child>
           <object class="GtkLabel" id="firmware_upgrade">
@@ -492,3 +516,4 @@
     </child>
   </template>
 </interface>
+
Index: gnome-control-center/panels/info/meson.build
===================================================================
--- gnome-control-center.orig/panels/info/meson.build
+++ gnome-control-center/panels/info/meson.build
@@ -54,6 +54,7 @@ sources = files(gsd_sources) + files(
   'cc-info-removable-media-panel.c',
   'dmi-info.c',
   'info-cleanup.c',
+  'pop-upgrade.c',
   's76-firmware.c',
   's76-firmware-daemon.c',
   's76-firmware-dialog.c',
@@ -127,4 +128,4 @@ script = configure_file(
 run_target(
   script_name,
   command: script
-)
+)
\ No newline at end of file
Index: gnome-control-center/panels/info/pop-upgrade.c
===================================================================
--- /dev/null
+++ gnome-control-center/panels/info/pop-upgrade.c
@@ -0,0 +1,526 @@
+#include "pop-upgrade.h"
+#include <glib/gi18n.h>
+
+const char *METHOD_FETCH_UPDATES = "FetchUpdates";
+const char *METHOD_RECOVERY_UPGRADE_FILE = "RecoveryUpgradeFile";
+const char *METHOD_RECOVERY_UPGRADE_RELEASE = "RecoveryUpgradeRelease";
+const char *METHOD_RELEASE_CHECK = "ReleaseCheck";
+const char *METHOD_RELEASE_UPGRADE = "ReleaseUpgrade";
+const char *METHOD_RELEASE_REPAIR = "ReleaseRepair";
+const char *METHOD_STATUS = "Status";
+const char *METHOD_PACKAGE_UPGRADE = "UpgradePackages";
+
+const guint8 POP_UPGRADE_RELEASE_METHOD_OFFLINE = 1;
+const guint8 POP_UPGRADE_RELEASE_METHOD_RECOVERY = 2;
+
+const gchar *POP_UPGRADE_SIGNAL_PACKAGE_FETCH_RESULT = "PackageFetchResult";
+const gchar *POP_UPGRADE_SIGNAL_PACKAGE_FETCHING = "PackageFetching";
+const gchar *POP_UPGRADE_SIGNAL_PACKAGE_FETCHED = "PackageFetched";
+const gchar *POP_UPGRADE_SIGNAL_PACKAGE_UPGRADE = "PackageUpgrade";
+const gchar *POP_UPGRADE_SIGNAL_RECOVERY_DOWNLOAD_PROGRESS = "RecoveryDownloadProgress";
+const gchar *POP_UPGRADE_SIGNAL_RECOVERY_EVENT = "RecoveryUpgradeEvent";
+const gchar *POP_UPGRADE_SIGNAL_RECOVERY_RESULT = "RecoveryUpgradeResult";
+const gchar *POP_UPGRADE_SIGNAL_RELEASE_EVENT = "ReleaseUpgradeEvent";
+const gchar *POP_UPGRADE_SIGNAL_RELEASE_RESULT = "ReleaseUpgradeResult";
+
+const guint8 POP_UPGRADE_STATUS_INACTIVE = 0;
+const guint8 POP_UPGRADE_STATUS_FETCHING_PACKAGES = 1;
+const guint8 POP_UPGRADE_STATUS_RECOVERY_UPGRADE = 2;
+const guint8 POP_UPGRADE_STATUS_RELEASE_UPGRADE = 3;
+const guint8 POP_UPGRADE_STATUS_PACKAGE_UPGRADE = 4;
+
+const gchar *POP_UPGRADE_BUS_NAME = "com.system76.PopUpgrade";
+const gchar *POP_UPGRADE_OBJECT_PATH = "/com/system76/PopUpgrade";
+const gchar *POP_UPGRADE_INTERFACE_NAME = "com.system76.PopUpgrade";
+
+const gchar *pop_upgrade_recovery_event_as_str (guint8 event) {
+  switch (event) {
+  case 1:
+    return _("Fetching recovery files");
+  case 2:
+    return _("Verifying checksums of fetched files");
+  case 3:
+    return _("Syncing recovery files with recovery partition");
+  case 4:
+    return _("Recovery partition upgrade completed");
+  case 5:
+    return _("Recovery partition upgrade failed");
+  default:
+    return NULL;
+  }
+}
+
+const gchar *pop_upgrade_release_event_as_str (guint8 event) {
+  switch (event) {
+  case 1:
+    return _("Updating package lists for the current release");
+  case 2:
+    return _("Fetching updated packages for the current release");
+  case 3:
+    return _("Upgrading packages for the current release");
+  case 4:
+    return _("Ensuring that system-critical packages are installed");
+  case 5:
+    return _("Update the source lists to the new release");
+  case 6:
+    return _("Fetching packages for the new release");
+  case 7:
+    return _("Attempting live upgrade to the new release");
+  case 8:
+    return _("Setting up the system to perform an offline upgrade on the next boot");
+  case 9:
+    return _("Setting up the recovery partition to install the new release");
+  case 10:
+    return _("The new release is ready to install");
+  case 11:
+    return _("The new release was successfully installed");
+  case 12:
+    return _("An error occurred while setting up the release upgrade");
+  default:
+    return NULL;
+  }
+}
+
+const gchar *pop_upgrade_get_channel (void) {
+  return "nvidia";
+}
+
+gboolean pop_upgrade_recovery_partition_exists (void) {
+  g_autoptr(GError) error = NULL;
+  g_autofree gchar *contents = NULL;
+
+  return g_file_get_contents ("/proc/mounts", &contents, NULL, &error)
+    && NULL != contents
+    && NULL != g_strrstr (contents, "/recovery");
+}
+
+ReleaseCheck release_check_new (void) {
+    ReleaseCheck status = { NULL, NULL, -1 };
+    return status;
+}
+
+static gboolean release_check_is (ReleaseCheck *self, const gchar *version, gint16 build) {
+  return NULL != self
+    && self->build == build
+    && 0 == g_strcmp0 (version, self->next);
+}
+
+gboolean pop_upgrade_recovery_partition_requires_upgrade (ReleaseCheck *expected) {
+  g_autoptr(GError) error = NULL;
+  g_autofree gchar *contents = NULL;
+  g_autofree gchar *release = NULL;
+  gint16 iso = 0;
+
+  return g_file_get_contents ("/recovery/version", &contents, NULL, &error)
+    && NULL != contents
+    && 1 == sscanf (contents, "%s %hd", &release, &iso)
+    && release_check_is (expected, release, iso);
+}
+
+PopUpgradeDaemonStatus pop_upgrade_daemon_status_new (void) {
+  PopUpgradeDaemonStatus status = { 0, 0 };
+  return status;
+}
+
+void release_check_free (ReleaseCheck *self) {
+    if (NULL != self) {
+        g_clear_pointer (&self->current, g_free);
+        g_clear_pointer (&self->next, g_free);
+    }
+}
+
+G_DEFINE_AUTOPTR_CLEANUP_FUNC (ReleaseCheck, release_check_free);
+
+PopUpgradeDaemon pop_upgrade_daemon_new (void) {
+    PopUpgradeDaemon daemon = { NULL };
+    return daemon;
+}
+
+int pop_upgrade_daemon_connect (PopUpgradeDaemon *self, GError **error) {
+    g_info ("attempting to connect to the Pop upgrade daemon");
+
+    self->proxy = g_dbus_proxy_new_for_bus_sync (
+        G_BUS_TYPE_SYSTEM, G_DBUS_PROXY_FLAGS_NONE, NULL,
+        POP_UPGRADE_BUS_NAME, POP_UPGRADE_OBJECT_PATH,
+        POP_UPGRADE_INTERFACE_NAME, NULL, error);
+
+    if (self->proxy == NULL) {
+        g_warning ("failed to reach PopUpgrade: %s", (*error)->message);
+        return -1;
+    }
+
+    return 0;
+}
+
+int pop_upgrade_daemon_recovery_upgrade_by_release (PopUpgradeDaemon *self,
+                                                    GError **error,
+                                                    const gchar *version,
+                                                    const gchar *arch, guint8 flags) {
+    g_info ("upgrading the recovery partition by release");
+
+    GVariant *input[3];
+    input[0] = g_variant_new_string (version);
+    input[1] = g_variant_new_string (arch);
+    input[2] = g_variant_new_byte (flags);
+
+    g_autoptr(GVariant) retval = g_dbus_proxy_call_sync (self->proxy, METHOD_RECOVERY_UPGRADE_RELEASE,
+                                                         g_variant_new_tuple (input, 3),
+                                                         G_DBUS_CALL_FLAGS_NONE, -1, NULL, error);
+
+    if (*error != NULL) {
+      g_warning ("failed to call %s on PopUpgrade: %s", METHOD_RECOVERY_UPGRADE_RELEASE, (*error)->message);
+      return -1;
+    }
+
+    return 0;
+}
+
+int pop_upgrade_daemon_release_check (PopUpgradeDaemon *self, GError **error, ReleaseCheck *status) {
+    g_info ("checking for a new Pop release");
+    if (NULL == status) {
+        g_warning ("status input is null, when it should not be");
+        return -1;
+    }
+
+    g_autoptr(GVariant) retval = NULL;
+
+    retval = g_dbus_proxy_call_sync (self->proxy, METHOD_RELEASE_CHECK, NULL,
+                                     G_DBUS_CALL_FLAGS_NONE, -1, NULL, error);
+
+    if (*error != NULL) {
+        g_warning ("failed to call %s on PopUpgrade: %s", METHOD_RELEASE_CHECK, (*error)->message);
+        return -1;
+    }
+
+    const char *expected = "(ssn)";
+
+    if (retval == NULL) {
+      g_warning ("failed to call %s on PopUpgrade: expected %s, but received nothing",
+                 METHOD_STATUS, expected);
+      return -2;
+    }
+
+    g_variant_get (retval, expected, &status->current, &status->next, &status->build);
+
+    return 0;
+}
+
+int pop_upgrade_daemon_release_upgrade (PopUpgradeDaemon *self, GError **error, guint8 how,
+                                        const gchar *from, const gchar *to)
+{
+    g_info ("beginning release upgrade for Pop");
+
+    GVariant *input[3];
+    input[0] = g_variant_new_byte (how);
+    input[1] = g_variant_new_string (from);
+    input[2] = g_variant_new_string (to);
+
+    g_autoptr(GVariant) retval = g_dbus_proxy_call_sync (self->proxy, METHOD_RELEASE_UPGRADE,
+                                                         g_variant_new_tuple (input, 3),
+                                                         G_DBUS_CALL_FLAGS_NONE, -1, NULL, error);
+
+    if (*error != NULL) {
+        g_warning ("failed to call %s on PopUpgrade: %s", METHOD_RELEASE_UPGRADE, (*error)->message);
+        return -1;
+    }
+
+    return 0;
+}
+
+int pop_upgrade_daemon_repair (PopUpgradeDaemon *self, GError **error) {
+    g_info ("pop is checking for required system repairs");
+
+    g_autoptr(GVariant) retval = g_dbus_proxy_call_sync (self->proxy, METHOD_RELEASE_REPAIR, NULL,
+                                                         G_DBUS_CALL_FLAGS_NONE, -1, NULL, error);
+
+    if (*error != NULL) {
+        g_warning ("failed to call %s on PopUpgrade: %s", METHOD_RELEASE_REPAIR, (*error)->message);
+        return -1;
+    }
+
+    return 0;
+}
+
+int pop_upgrade_daemon_status (PopUpgradeDaemon *self, GError **error, PopUpgradeDaemonStatus *status) {
+    g_info ("checking the status of the Pop upgrade daemon");
+
+    if (NULL == self || NULL == self->proxy) {
+      g_warning ("pop_upgrade_daemon_status called with null daemon/proxy");
+      return -1;
+    }
+
+    g_autoptr(GVariant) retval = g_dbus_proxy_call_sync (self->proxy, METHOD_STATUS, NULL,
+                                                         G_DBUS_CALL_FLAGS_NONE, -1, NULL, error);
+
+    if (error != NULL && *error != NULL) {
+        g_warning ("failed to call %s on PopUpgrade: %s", METHOD_STATUS, (*error)->message);
+        return -1;
+    }
+
+    const char *expected = "(yy)";
+
+    if (retval == NULL) {
+      g_warning ("failed to call %s on PopUpgrade: expected %s, but received nothing", METHOD_STATUS, expected);
+      return -2;
+    }
+
+    status->status = g_variant_get_byte (
+      g_variant_get_child_value (retval, 0)
+    );
+
+    status->sub_status = g_variant_get_byte (
+      g_variant_get_child_value (retval, 1)
+    );
+
+    return 0;
+}
+
+static PopUpgradeOption pop_upgrade_option_new (const gchar *name) {
+  // On click, this will initiate the pop upgrade process.
+  GtkWidget *button = gtk_button_new ();
+  gtk_label_set_use_markup (GTK_LABEL (gtk_bin_get_child (GTK_BIN (button))), TRUE);
+  gtk_widget_set_can_focus (button, TRUE);
+  gtk_widget_set_valign (button, GTK_ALIGN_CENTER);
+  gtk_style_context_add_class (gtk_widget_get_style_context (button),
+                               GTK_STYLE_CLASS_SUGGESTED_ACTION);
+
+  // The label to describe availability of an upgrade.
+  GtkWidget *label = gtk_label_new (NULL);
+  gtk_label_set_xalign (GTK_LABEL (label), 0);
+  gtk_label_set_use_underline (GTK_LABEL (label), TRUE);
+  gtk_label_set_mnemonic_widget (GTK_LABEL (label), button);
+
+  // A box for containing the label and button.
+  GtkWidget *button_box = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 12);
+  gtk_container_add (GTK_CONTAINER (button_box), label);
+  gtk_box_pack_end (GTK_BOX (button_box), button, FALSE, FALSE, FALSE);
+
+  // Displays progress of the release upgrade in progress.
+  GtkWidget *progress = gtk_progress_bar_new ();
+  gtk_progress_bar_set_ellipsize (GTK_PROGRESS_BAR (progress), PANGO_ELLIPSIZE_END);
+  gtk_progress_bar_set_show_text (GTK_PROGRESS_BAR (progress), TRUE);
+
+  // Stack for containing the button box and progress bar.
+  GtkWidget *stack = gtk_stack_new ();
+  gtk_container_add (GTK_CONTAINER (stack), button_box);
+  gtk_container_add (GTK_CONTAINER (stack), progress);
+  gtk_widget_set_margin_start (stack, 20);
+  gtk_widget_set_margin_end (stack, 20);
+  gtk_widget_set_margin_top (stack, 9);
+  gtk_widget_set_margin_bottom (stack, 9);
+  gtk_widget_set_visible (stack, TRUE);
+  gtk_widget_show_all (stack);
+  gtk_stack_set_visible_child (GTK_STACK (stack), button_box);
+
+  PopUpgradeOption option = { FALSE, TRUE, NULL, name, button, label, button_box, progress, stack };
+  return option;
+}
+
+void pop_upgrade_option_restore_label (PopUpgradeOption *self) {
+  if (NULL != self->label_text) {
+    gtk_label_set_text (GTK_LABEL (self->label), self->label_text);
+    g_clear_pointer (&self->label_text, g_free);
+  }
+}
+
+void pop_upgrade_option_reset_options (PopUpgradeOption *options[]) {
+  g_info ("resetting options");
+  for (int i = 0; NULL != options[i]; i++) {
+    PopUpgradeOption *option = options[i];
+    gtk_widget_set_sensitive (option->button, option->actionable);
+    pop_upgrade_option_restore_label (option);
+  }
+}
+
+void pop_upgrade_option_initiate_action (
+  PopUpgradeOption *self,
+  PopUpgradeOption *options[],
+  const gchar *action_label,
+  const gchar *wait_label
+) {
+  g_info ("initiating upgrade option widget changes");
+  for (int i = 0; NULL != options[i]; i++) {
+    PopUpgradeOption *option = options[i];
+    option->active = FALSE;
+    gtk_widget_set_sensitive (option->button, FALSE);
+    pop_upgrade_option_set_temporary_label (option, wait_label);
+  }
+
+  gtk_stack_set_visible_child (GTK_STACK (self->stack), self->progress);
+  gtk_progress_bar_set_text (GTK_PROGRESS_BAR (self->progress), action_label);
+  gtk_progress_bar_set_fraction (GTK_PROGRESS_BAR (self->progress), 0.0);
+  self->active = TRUE;
+}
+
+void pop_upgrade_option_set_label (PopUpgradeOption *self, const gchar *label) {
+  gtk_label_set_label (GTK_LABEL (self->label), label);
+}
+
+void pop_upgrade_option_set_temporary_label (PopUpgradeOption *self, const gchar *label) {
+  g_clear_pointer (&self->label_text, g_free);
+  self->label_text = g_strdup (gtk_label_get_text (GTK_LABEL (self->label)));
+  gtk_label_set_text (GTK_LABEL (self->label), label);
+}
+
+void pop_upgrade_option_try_again (
+  PopUpgradeOption *self,
+  PopUpgradeOption *options[],
+  const gchar *why
+) {
+  gtk_stack_set_visible_child (GTK_STACK (self->stack), self->button_box);
+  gtk_label_set_text (GTK_LABEL (self->label), why);
+  gtk_button_set_label (GTK_BUTTON (self->button), _("Try Again"));
+  self->active = FALSE;
+
+  pop_upgrade_option_reset_options (options);
+}
+
+void pop_upgrade_package_fetched (PopUpgradeOption *active,
+                                  GVariant *parameters)
+{
+  g_info ("pop_upgrade: package fetch event");
+
+  g_autoptr(GVariant) inner = g_variant_get_child_value (parameters, 0);
+  g_autoptr(GVariant) p1 = g_variant_get_child_value (parameters, 1);
+  g_autoptr(GVariant) p2 = g_variant_get_child_value (parameters, 2);
+
+  gsize length = 0;
+  const gchar *temp_str = g_variant_get_string (inner, &length);
+  g_autofree gchar *package = g_strndup (temp_str, length);
+
+  if (NULL != package) {
+    guint32 completed = g_variant_get_uint32 (p1);
+    guint32 total = g_variant_get_uint32 (p2);
+    double percent = (double) completed / (double) total;
+
+    g_info ("fetched %s (%d/%d: %f)", package, completed, total, percent);
+    gtk_progress_bar_set_fraction (GTK_PROGRESS_BAR (active->progress), percent);
+  }
+}
+
+void pop_upgrade_package_fetching (PopUpgradeOption *active,
+                                   GVariant *parameters)
+{
+  g_info ("pop_upgrade: package fetching event");
+  g_autoptr(GVariant) inner = g_variant_get_child_value (parameters, 0);
+  gsize length = 0;
+  const gchar *temp_str = g_variant_get_string (inner, &length);
+  g_autofree gchar *package = g_strndup (temp_str, length);
+  if (NULL != package) {
+    g_autofree gchar *desc = g_strdup_printf (_("Fetching %s"), package);
+    gtk_progress_bar_set_text (GTK_PROGRESS_BAR (active->progress), desc);
+  }
+}
+
+void pop_upgrade_package_upgrade (PopUpgradeOption *active,
+                                  GVariant *parameters)
+{
+  g_autoptr(GVariant) inner = g_variant_get_child_value (parameters, 0);
+
+  gchar *fst, *scd, *thd;
+  fst = scd = thd = NULL;
+
+  g_autofree gchar *desc = NULL;
+
+  if (g_variant_lookup (inner, "processing_package", "&s", (gpointer) &fst)) {
+    desc = g_strdup_printf (_("Processing triggers for %s"), fst);
+  } else if (g_variant_lookup (inner, "percent", "&s", (gpointer) &fst)) {
+    guint16 percent = 0;
+    if (1 == sscanf (fst, "%hi", &percent)) {
+      double fraction = (double) percent / (double) 100;
+      gtk_progress_bar_set_fraction (GTK_PROGRESS_BAR (active->progress), fraction);
+    } else {
+      g_warning (_("Failed to read percent value"));
+    }
+  } else if (g_variant_lookup (inner, "setting_up", "&s", (gpointer) &fst)) {
+    desc = g_strdup_printf (_("Setting up %s"), fst);
+  } else if (g_variant_lookup (inner, "over", "&s", (gpointer) &fst)) {
+    gboolean res = g_variant_lookup (inner, "version", "&s", (gpointer) &scd)
+      && g_variant_lookup (inner, "unpacking", "&s", (gpointer) &thd);
+
+    if (res) {
+      desc = g_strdup_printf (_("Unpacking %s (%s) over %s"), thd, scd, fst);
+    } else {
+      g_warning (_("Failed to read unpacking value"));
+    }
+  }
+
+  if (desc) {
+    gtk_progress_bar_set_text (GTK_PROGRESS_BAR (active->progress), desc);
+  }
+}
+
+void pop_upgrade_recovery_download_progress (PopUpgradeOption *active,
+                                             GVariant *parameters)
+{
+  g_info ("pop_upgrade: recovery download progress event");
+
+  g_autoptr(GVariant) p0 = g_variant_get_child_value (parameters, 0);
+  g_autoptr(GVariant) p1 = g_variant_get_child_value (parameters, 1);
+  guint64 progress = g_variant_get_uint64 (p0);
+  guint64 total = g_variant_get_uint64 (p1);
+
+  double fraction = (double) total / (double) progress;
+  g_autofree gchar *desc = g_strdup_printf (
+    _("Recovery files downloading: %d%%"),
+    (int) (fraction * 100)
+  );
+
+  gtk_progress_bar_set_text (GTK_PROGRESS_BAR (active->progress), desc);
+  gtk_progress_bar_set_fraction (GTK_PROGRESS_BAR (active->progress), fraction);
+}
+
+void pop_upgrade_event_event (PopUpgradeOption *active,
+                              GVariant *parameters,
+                              const gchar *(*callback)(guint8))
+{
+  g_info ("pop_upgrade: processing event");
+  g_autoptr(GVariant) inner = g_variant_get_child_value (parameters, 0);
+  guint8 event = g_variant_get_byte (inner);
+  const gchar *msg = (*callback)(event);
+  if (NULL != msg) {
+    gtk_progress_bar_set_text (GTK_PROGRESS_BAR (active->progress), msg);
+  }
+}
+
+PopUpgradeWidgets pop_upgrade_frame (GtkFrame *frame) {
+  if (NULL == frame) {
+    g_critical ("pop_upgrade_frame: received NULL input");
+  }
+
+  PopUpgradeOption os = pop_upgrade_option_new ("os");
+  PopUpgradeOption rec = pop_upgrade_option_new ("recovery");
+
+  // Each row is added to a list, primarily used for visual style.
+  GtkWidget *list = gtk_list_box_new ();
+  gtk_widget_set_can_focus (list, TRUE);
+  gtk_list_box_set_selection_mode (GTK_LIST_BOX (list), GTK_SELECTION_NONE);
+  gtk_container_add (GTK_CONTAINER (list), os.stack);
+  gtk_container_add (GTK_CONTAINER (list), rec.stack);
+  gtk_widget_show_all (list);
+
+  // Add the list to the UI in the upgrade frame.
+  gtk_container_add (GTK_CONTAINER (frame), list);
+
+  PopUpgradeWidgets widgets = { os, rec };
+  return widgets;
+}
+
+GtkWidget *pop_upgrade_recovery_partition_dialog (void) {
+  GtkWidget *dialog = gtk_dialog_new ();
+  gtk_window_set_destroy_with_parent (GTK_WINDOW (dialog), TRUE);
+  gtk_window_set_title (GTK_WINDOW (dialog), _("Upgrade Recovery Partition"));
+
+  gtk_dialog_add_button (GTK_DIALOG (dialog), _("_Cancel"), GTK_RESPONSE_CANCEL);
+  GtkWidget *ok_button = gtk_dialog_add_button (GTK_DIALOG (dialog), _("_OK"), GTK_RESPONSE_OK);
+  gtk_widget_grab_default (ok_button);
+
+  GtkWidget *label = gtk_label_new (_("Updating the recovery partition is required \
+    to perform a release upgrade with the recovery partition.\n\nUpgrade the recovery partition?"));
+
+  GtkWidget *content_area = gtk_dialog_get_content_area (GTK_DIALOG (dialog));
+  gtk_container_add (GTK_CONTAINER (content_area), label);
+  gtk_widget_show_all (dialog);
+
+  return dialog;
+}
Index: gnome-control-center/panels/info/pop-upgrade.h
===================================================================
--- /dev/null
+++ gnome-control-center/panels/info/pop-upgrade.h
@@ -0,0 +1,177 @@
+#include <gio/gio.h>
+#include <glib.h>
+#include <gtk/gtk.h>
+#include <gmodule.h>
+
+extern const gchar *POP_UPGRADE_SIGNAL_PACKAGE_FETCH_RESULT;
+extern const gchar *POP_UPGRADE_SIGNAL_PACKAGE_FETCHING;
+extern const gchar *POP_UPGRADE_SIGNAL_PACKAGE_FETCHED;
+extern const gchar *POP_UPGRADE_SIGNAL_PACKAGE_UPGRADE;
+extern const gchar *POP_UPGRADE_SIGNAL_RECOVERY_DOWNLOAD_PROGRESS;
+extern const gchar *POP_UPGRADE_SIGNAL_RECOVERY_EVENT;
+extern const gchar *POP_UPGRADE_SIGNAL_RECOVERY_RESULT;
+extern const gchar *POP_UPGRADE_SIGNAL_RELEASE_EVENT;
+extern const gchar *POP_UPGRADE_SIGNAL_RELEASE_RESULT;
+
+extern const guint8 POP_UPGRADE_STATUS_INACTIVE;
+extern const guint8 POP_UPGRADE_STATUS_FETCHING_PACKAGES;
+extern const guint8 POP_UPGRADE_STATUS_RECOVERY_UPGRADE;
+extern const guint8 POP_UPGRADE_STATUS_RELEASE_UPGRADE;
+extern const guint8 POP_UPGRADE_STATUS_PACKAGE_UPGRADE;
+
+extern const guint8 POP_UPGRADE_RELEASE_METHOD_OFFLINE;
+extern const guint8 POP_UPGRADE_RELEASE_METHOD_RECOVERY;
+
+extern const char *POP_UPGRADE_METHOD_FETCH_UPDATES;
+extern const char *POP_UPGRADE_METHOD_RECOVERY_UPGRADE_FILE;
+extern const char *POP_UPGRADE_METHOD_RECOVERY_UPGRADE_RELEASE;
+extern const char *POP_UPGRADE_METHOD_RELEASE_CHECK;
+extern const char *POP_UPGRADE_METHOD_RELEASE_UPGRAD;
+extern const char *POP_UPGRADE_METHOD_RELEASE_REPAIR;
+extern const char *POP_UPGRADE_METHOD_STATUS;
+extern const char *POP_UPGRADE_METHOD_PACKAGE_UPGRADE;
+
+extern const gchar *POP_UPGRADE_BUS_NAME;
+extern const gchar *POP_UPGRADE_OBJECT_PATH;
+extern const gchar *POP_UPGRADE_INTERFACE_NAME;
+
+// Fetch a static string which corresponds to an event ID.
+//
+// Returns `NULL` if the event ID is out of range.
+const gchar *pop_upgrade_recovery_event_as_str (guint8 event);
+
+// Fetch a static string which corresponds to an event ID.
+//
+// Returns `NULL` if the event ID is out of range.
+const gchar *pop_upgrade_release_event_as_str (guint8 event);
+
+// Fetches the string that determins which release channel to fetch.
+//
+// Possible values are `intel` and `nvidia`.
+const gchar *pop_upgrade_get_channel (void);
+
+// When used with `pop_upgrade_daemon_release_check ()`, this will contain the
+// current release version, the next release version, and whether the next
+// release is available.
+typedef struct {
+    gchar *current;
+    gchar *next;
+    gint16 build;
+} ReleaseCheck;
+
+// Constructs a new release status struct
+ReleaseCheck release_check_new (void);
+
+// Free strings which are contained within struct.
+void release_check_free (ReleaseCheck *self);
+
+// Check if the recovery partition exists.
+//
+// This is true if a device in `/proc/mounts` is mounted to `/recovery`.
+gboolean pop_upgrade_recovery_partition_exists (void);
+
+// Check if the recovery partition requires an upgrade.
+gboolean pop_upgrade_recovery_partition_requires_upgrade (ReleaseCheck *expected);
+
+// When used ith `pop_upgrade_daemon_release_status ()`, this will contain the
+// status of the daemon.
+typedef struct {
+    guint8 status;
+    guint8 sub_status;
+} PopUpgradeDaemonStatus;
+
+// Constructs a new daemon status struct.
+PopUpgradeDaemonStatus pop_upgrade_daemon_status_new (void);
+
+// Manages a connection to Pop's upgrade daemon.
+typedef struct {
+    GDBusProxy *proxy;
+} PopUpgradeDaemon;
+
+// Creates an empty value which hasn't been connected yet.
+PopUpgradeDaemon pop_upgrade_daemon_new (void);
+
+// Attempts to connect the empty daemon value to the daemon.
+int pop_upgrade_daemon_connect (PopUpgradeDaemon *self, GError **error);
+
+// Ask the daemon to perform a recovery upgrade by the Pop release API
+int pop_upgrade_daemon_recovery_upgrade_by_release (PopUpgradeDaemon *self,
+                                                    GError **error, const gchar *version,
+                                                    const gchar *channel, guint8 flags);
+
+// Ask the daemon if a new release is available.
+int pop_upgrade_daemon_release_check (PopUpgradeDaemon *self,
+                                      GError **error, ReleaseCheck *status);
+
+/// Ask the daemon to perform a release upgrade.
+int pop_upgrade_daemon_release_upgrade(PopUpgradeDaemon *self, GError **error,
+                                       guint8 how, const gchar *from, const gchar *to);
+
+// Ask the daemon to attempt to perform any system repairs necessary.
+int pop_upgrade_daemon_repair (PopUpgradeDaemon *self, GError **error);
+
+// Ask the daemon about its current status.
+int pop_upgrade_daemon_status (PopUpgradeDaemon *self,
+                               GError **error,
+                               PopUpgradeDaemonStatus *status);
+
+typedef struct {
+    gboolean    active;
+    gboolean    actionable;
+    gchar       *label_text;
+    const gchar *name;
+    GtkWidget   *button;
+    GtkWidget   *label;
+    GtkWidget   *button_box;
+    GtkWidget   *progress;
+    GtkWidget   *stack;
+} PopUpgradeOption;
+
+// Updates the option labels to signal that the process has begun.
+// Update all other options to require the user to wait until it is finished.
+void pop_upgrade_option_initiate_action (
+  PopUpgradeOption *self,
+  PopUpgradeOption *options[],
+  const gchar *action_label,
+  const gchar *wait_label
+);
+
+// Restores the previous label.
+void pop_upgrade_option_restore_label (PopUpgradeOption *self);
+
+// Sets a new label without retaining the previous label.
+void pop_upgrade_option_set_label (PopUpgradeOption *self, const gchar *label);
+
+// Retains the previous label while setting a new label.
+void pop_upgrade_option_set_temporary_label (PopUpgradeOption *self, const gchar *label);
+
+// Sets the "Try Again" label and restores the original label.
+void pop_upgrade_option_try_again (PopUpgradeOption *self, PopUpgradeOption **options,
+                                   const gchar *why);
+
+void pop_upgrade_package_fetched (PopUpgradeOption *active,
+                                  GVariant *parameters);
+
+void pop_upgrade_package_fetching (PopUpgradeOption *active,
+                                   GVariant *parameters);
+
+void pop_upgrade_package_upgrade (PopUpgradeOption *active,
+                                  GVariant *parameters);
+
+void pop_upgrade_recovery_download_progress (PopUpgradeOption *active,
+                                             GVariant *parameters);
+
+void pop_upgrade_event_event (PopUpgradeOption *active,
+                              GVariant *parameters,
+                              const gchar *(*callback)(guint8));
+
+void pop_upgrade_option_reset_options (PopUpgradeOption *options[]);
+
+typedef struct {
+    PopUpgradeOption os;
+    PopUpgradeOption rec;
+} PopUpgradeWidgets;
+
+PopUpgradeWidgets pop_upgrade_frame (GtkFrame *frame);
+
+GtkWidget *pop_upgrade_recovery_partition_dialog (void);
