Index: gnome-control-center/panels/info/cc-info-overview-panel.c
===================================================================
--- gnome-control-center.orig/panels/info/cc-info-overview-panel.c
+++ gnome-control-center/panels/info/cc-info-overview-panel.c
@@ -49,6 +49,7 @@
 #include "cc-info-overview-panel.h"
 #include "dmi-info.h"
 #include "gsd-disk-space-helper.h"
+#include "pop-upgrade.h"
 #include "s76-firmware.h"
 #include <polkit/polkit.h>
 
@@ -80,6 +81,7 @@ typedef struct
   GtkWidget      *firmware_button;
   GtkWidget      *lock_button;
   GtkWidget      *lock_header;
+  GtkWidget      *os_upgrade_frame;
   GPermission    *permission;
 
   S76FirmwareDaemon  *firmware_daemon;
@@ -87,6 +89,12 @@ typedef struct
   gchar              *firmware_digest;
   gchar              *firmware_changelog;
 
+  PopUpgradeWidgets   pop_upgrade;
+  PopUpgradeDaemon   *upgrade_daemon;
+  ReleaseCheck       *release_check;
+  guint               os_subscribe;
+  guint               os_subscribe_idle;
+
   /* Virtualisation labels */
   GtkWidget      *label8;
   GtkWidget      *grid1;
@@ -868,9 +876,15 @@ cc_info_overview_panel_dispose (GObject
 
   g_clear_pointer (&priv->graphics_data, graphics_data_free);
   g_clear_pointer (&priv->firmware_version, s76_firmware_version_free);
+  g_clear_pointer (&priv->release_check, release_check_free);
   g_slice_free (S76FirmwareDaemon, priv->firmware_daemon);
+  g_slice_free (PopUpgradeDaemon, priv->upgrade_daemon);
   g_clear_object (&priv->permission);
 
+  if (0 != priv->os_subscribe_idle) {
+    g_source_remove (priv->os_subscribe_idle);
+  }
+
   G_OBJECT_CLASS (cc_info_overview_panel_parent_class)->dispose (object);
 }
 
@@ -960,6 +974,308 @@ s76_firmware_dialog (GtkButton *button,
 }
 
 static void
+pop_upgrade_set_try_again (CcInfoOverviewPanelPrivate *self, const gchar *why)
+{
+  gtk_stack_set_visible_child (GTK_STACK (self->pop_upgrade.os.stack), self->pop_upgrade.os.button_box);
+  gtk_label_set_text (GTK_LABEL (self->pop_upgrade.os.label), why);
+  gtk_button_set_label (GTK_BUTTON (self->pop_upgrade.os.button), _("Try Again"));
+}
+
+static void
+pop_upgrade_failed (CcInfoOverviewPanelPrivate *self,
+                    GDBusConnection *connection,
+                    const gchar *why)
+{
+  g_info ("pop_upgrade: upgrade failed: %s", why);
+  g_dbus_connection_signal_unsubscribe (connection, self->os_subscribe);
+  self->os_subscribe = 0;
+  pop_upgrade_set_try_again (self, why);
+}
+
+static void
+pop_upgrade_package_fetched (CcInfoOverviewPanelPrivate *self,
+                             GDBusConnection *connection,
+                             GVariant *parameters)
+{
+  g_info ("pop_upgrade: package fetch event");
+
+  g_autoptr(GVariant) inner = g_variant_get_child_value (parameters, 0);
+  g_autoptr(GVariant) p1 = g_variant_get_child_value (parameters, 1);
+  g_autoptr(GVariant) p2 = g_variant_get_child_value (parameters, 2);
+
+  gsize length = 0;
+  const gchar *temp_str = g_variant_get_string (inner, &length);
+  g_autofree gchar *package = g_strndup (temp_str, length);
+
+  if (NULL != package) {
+    guint32 completed = g_variant_get_uint32 (p1);
+    guint32 total = g_variant_get_uint32 (p2);
+    double percent = (double) completed / (double) total;
+
+    g_info ("fetched %s (%d/%d: %f)", package, completed, total, percent);
+    gtk_progress_bar_set_fraction (GTK_PROGRESS_BAR (self->pop_upgrade.os.progress), percent);
+  }
+}
+
+static void
+pop_upgrade_package_fetching (CcInfoOverviewPanelPrivate *self,
+                              GDBusConnection *connection,
+                              GVariant *parameters)
+{
+  g_info ("pop_upgrade: package fetching event");
+  g_autoptr(GVariant) inner = g_variant_get_child_value (parameters, 0);
+  gsize length = 0;
+  const gchar *temp_str = g_variant_get_string (inner, &length);
+  g_autofree gchar *package = g_strndup (temp_str, length);
+  if (NULL != package) {
+    g_autofree gchar *desc = g_strdup_printf (_("Fetching %s"), package);
+    gtk_progress_bar_set_text (GTK_PROGRESS_BAR (self->pop_upgrade.os.progress), desc);
+  }
+}
+
+static void
+pop_upgrade_package_upgrade (CcInfoOverviewPanelPrivate *self,
+                             GDBusConnection *connection,
+                             GVariant *parameters)
+{
+  g_autoptr(GVariant) inner = g_variant_get_child_value (parameters, 0);
+
+  gchar *fst, *scd, *thd;
+  fst = scd = thd = NULL;
+
+  g_autofree gchar *desc = NULL;
+
+  if (g_variant_lookup (inner, "processing_package", "&s", (gpointer) &fst)) {
+    desc = g_strdup_printf (_("Processing triggers for %s"), fst);
+  } else if (g_variant_lookup (inner, "percent", "&s", (gpointer) &fst)) {
+    guint16 percent = 0;
+    if (1 == sscanf (fst, "%hi", &percent)) {
+      double fraction = (double) percent / (double) 100;
+      gtk_progress_bar_set_fraction (GTK_PROGRESS_BAR (self->pop_upgrade.os.progress), fraction);
+    } else {
+      g_warning (_("Failed to read percent value"));
+    }
+  } else if (g_variant_lookup (inner, "setting_up", "&s", (gpointer) &fst)) {
+    desc = g_strdup_printf (_("Setting up %s"), fst);
+  } else if (g_variant_lookup (inner, "over", "&s", (gpointer) &fst)) {
+    gboolean res = g_variant_lookup (inner, "version", "&s", (gpointer) &scd)
+      && g_variant_lookup (inner, "unpacking", "&s", (gpointer) &thd);
+
+    if (res) {
+      desc = g_strdup_printf (_("Unpacking %s (%s) over %s"), thd, scd, fst);
+    } else {
+      g_warning (_("Failed to read unpacking value"));
+    }
+  }
+
+  if (desc) {
+    gtk_progress_bar_set_text (GTK_PROGRESS_BAR (self->pop_upgrade.os.progress), desc);
+  }
+}
+
+static void
+pop_upgrade_recovery_download_progress (CcInfoOverviewPanelPrivate *self, GDBusConnection *connection,
+                                        GVariant *parameters)
+{
+  g_info ("pop_upgrade: recovery download progress event");
+
+  g_autoptr(GVariant) p0 = g_variant_get_child_value (parameters, 0);
+  g_autoptr(GVariant) p1 = g_variant_get_child_value (parameters, 1);
+  guint64 progress = g_variant_get_uint64 (p0);
+  guint64 total = g_variant_get_uint64 (p1);
+
+  double fraction = (double) total / (double) progress;
+  g_autofree gchar *desc = g_strdup_printf (
+    _("Recovery files downloading: %d%%"),
+    (int) (fraction * 100)
+  );
+
+  gtk_progress_bar_set_text (GTK_PROGRESS_BAR (self->pop_upgrade.os.progress), desc);
+  gtk_progress_bar_set_fraction (GTK_PROGRESS_BAR (self->pop_upgrade.os.progress), fraction);
+}
+
+static void
+pop_upgrade_event_event (CcInfoOverviewPanelPrivate *self, GDBusConnection *connection,
+                         GVariant *parameters, const gchar *(*callback)(guint8))
+{
+  g_info ("pop_upgrade: processing event");
+  g_autoptr(GVariant) inner = g_variant_get_child_value (parameters, 0);
+  guint8 event = g_variant_get_byte (inner);
+  const gchar *msg = (*callback)(event);
+  if (NULL != msg) {
+    gtk_progress_bar_set_text (GTK_PROGRESS_BAR (self->pop_upgrade.os.progress), msg);
+  }
+}
+
+static gboolean
+pop_upgrade_event_result (CcInfoOverviewPanelPrivate *self, GDBusConnection *connection,
+                          GVariant *parameters, const gchar *ok, const gchar *err)
+{
+  g_info ("pop_upgrade: processing result");
+  g_autoptr(GVariant) inner = g_variant_get_child_value (parameters, 0);
+  guint8 result = g_variant_get_byte (inner);
+  if (0 == result) {
+    gtk_progress_bar_set_text (GTK_PROGRESS_BAR (self->pop_upgrade.os.progress), ok);
+    return TRUE;
+  } else {
+    pop_upgrade_failed (self, connection, err);
+    return FALSE;
+  }
+}
+
+static void
+pop_upgrade_event_listen (GDBusConnection            *connection,
+                          const gchar                *sender_name,
+                          const gchar                *object_path,
+                          const gchar                *interface_name,
+                          const gchar                *signal_name,
+                          GVariant                   *parameters,
+                          CcInfoOverviewPanelPrivate *self)
+{
+  g_info ("received upgrade signal:\n \
+    \tsignal_name: %s\n \
+    \tinterface_name: %s\n \
+    \tsender_name: %s\n \
+    \tobject_path: %s\n", signal_name, interface_name, sender_name, object_path);
+
+  g_info ("variant type returned: %s", g_variant_get_type_string (parameters));
+
+  if (0 == g_strcmp0 (POP_UPGRADE_SIGNAL_PACKAGE_FETCHED, signal_name)) {
+    pop_upgrade_package_fetched (self, connection, parameters);
+  } else if (0 == g_strcmp0 (POP_UPGRADE_SIGNAL_PACKAGE_FETCHING, signal_name)) {
+    pop_upgrade_package_fetching (self, connection, parameters);
+  } else if (0 == g_strcmp0 (POP_UPGRADE_SIGNAL_PACKAGE_UPGRADE, signal_name)) {
+    pop_upgrade_package_upgrade (self, connection, parameters);
+  } else if (0 == g_strcmp0 (POP_UPGRADE_SIGNAL_RECOVERY_DOWNLOAD_PROGRESS, signal_name)) {
+    pop_upgrade_recovery_download_progress (self, connection, parameters);
+  } else if (0 == g_strcmp0 (POP_UPGRADE_SIGNAL_RECOVERY_EVENT, signal_name)) {
+    pop_upgrade_event_event (self, connection, parameters,
+                             pop_upgrade_recovery_event_as_str);
+  } else if (0 == g_strcmp0 (POP_UPGRADE_SIGNAL_PACKAGE_FETCH_RESULT, signal_name)) {
+    g_info ("executing fetch result");
+    pop_upgrade_event_result (self, connection, parameters,
+                              _("Packages fetched successfully"),
+                              _("Failed to fetch package"));
+  } else if (0 == g_strcmp0 (POP_UPGRADE_SIGNAL_RECOVERY_RESULT, signal_name)) {
+    g_info ("executing recovery result");
+    pop_upgrade_event_result (self, connection, parameters,
+                              _("Recovery partition upgraded"),
+                              _("Failed to upgrade recovery partition"));
+  } else if (0 == g_strcmp0 (POP_UPGRADE_SIGNAL_RELEASE_EVENT, signal_name)) {
+    pop_upgrade_event_event (self, connection, parameters,
+                             pop_upgrade_release_event_as_str);
+  } else if (0 == g_strcmp0 (POP_UPGRADE_SIGNAL_RELEASE_RESULT, signal_name)) {
+    g_info ("executing release result");
+    const gchar *msg = _("Release ready. You may now restart.");
+    gboolean success = pop_upgrade_event_result (self, connection, parameters,
+                                                 msg,
+                                                 _("Failed to set up release upgrade"));
+
+    if (success) {
+      g_info ("success: %s", msg);
+      gtk_label_set_text (GTK_LABEL (self->pop_upgrade.os.label), msg);
+      gtk_stack_set_visible_child (GTK_STACK (self->pop_upgrade.os.stack), self->pop_upgrade.os.button_box);
+      g_dbus_connection_signal_unsubscribe (connection, self->os_subscribe);
+    }
+  }
+}
+
+typedef struct {
+  CcInfoOverviewPanelPrivate *priv;
+  guint expected_status;
+} ConnectionData;
+
+static gboolean
+pop_upgrade_check (ConnectionData *data)
+{
+  if (0 != data->priv->os_subscribe) {
+    PopUpgradeDaemon *daemon = data->priv->upgrade_daemon;
+    PopUpgradeDaemonStatus status = pop_upgrade_daemon_status_new ();
+    char *cause = "failed to fetch status from upgrade daemon";
+
+    if (0 == pop_upgrade_daemon_status (daemon, NULL, &status)) {
+      if (status.status == data->expected_status) {
+        return TRUE;
+      } else {
+        cause = "daemon status changed";
+      }
+    }
+
+    pop_upgrade_failed (data->priv,
+                        g_dbus_proxy_get_connection (daemon->proxy),
+                        cause);
+  }
+
+  data->priv->os_subscribe_idle = 0;
+  g_slice_free (ConnectionData, data);
+  return FALSE;
+}
+
+static void
+pop_upgrade_daemon_listen_upgrade_signals (CcInfoOverviewPanelPrivate *self)
+{
+    PopUpgradeDaemon *daemon = self->upgrade_daemon;
+    GDBusConnection *conn = g_dbus_proxy_get_connection (daemon->proxy);
+    self->os_subscribe = g_dbus_connection_signal_subscribe (
+      conn,
+      POP_UPGRADE_BUS_NAME,
+      POP_UPGRADE_INTERFACE_NAME,
+      NULL,
+      POP_UPGRADE_OBJECT_PATH,
+      NULL,
+      G_DBUS_SIGNAL_FLAGS_NONE,
+      pop_upgrade_event_listen,
+      self,
+      NULL
+    );
+
+    ConnectionData *data = g_slice_new0 (ConnectionData);
+    data->priv = self;
+    data->expected_status = POP_UPGRADE_STATUS_RELEASE_UPGRADE;
+    self->os_subscribe_idle = g_timeout_add (3000, pop_upgrade_check, data);
+}
+
+static void
+pop_upgrade (GtkButton *button,
+             CcInfoOverviewPanel *self)
+{
+  g_info ("Pop upgrade process starting");
+  CcInfoOverviewPanelPrivate *priv = cc_info_overview_panel_get_instance_private (self);
+  gtk_stack_set_visible_child (GTK_STACK (priv->pop_upgrade.os.stack), priv->pop_upgrade.os.progress);
+  gtk_progress_bar_set_text (GTK_PROGRESS_BAR (priv->pop_upgrade.os.progress), _("Initializing upgrade process"));
+  gtk_progress_bar_set_fraction (GTK_PROGRESS_BAR (priv->pop_upgrade.os.progress), 0.0);
+
+  g_info ("upgrading from %s to %s", priv->release_check->current,
+           priv->release_check->next);
+
+  g_autoptr(GError) error = NULL;
+  g_autofree gchar *error_message = NULL;
+
+  // Ensure that the /recovery partition is mounted, if it can be mounted.
+  // The daemon will safely fix other system isues as well, if it finds any.
+  if (0 == pop_upgrade_daemon_repair (priv->upgrade_daemon, &error)) {
+    guint8 method = (g_file_test ("/recovery", G_FILE_TEST_IS_DIR))
+      ? POP_UPGRADE_RELEASE_METHOD_RECOVERY
+      : POP_UPGRADE_RELEASE_METHOD_OFFLINE;
+
+    pop_upgrade_daemon_listen_upgrade_signals (priv);
+    int result = pop_upgrade_daemon_release_upgrade (priv->upgrade_daemon, &error, method,
+                                        priv->release_check->current,
+                                        priv->release_check->next);
+
+    if (0 != result) {
+      error_message = g_strdup_printf (_("Failed to start release upgrade: %s"), error->message);
+    }
+  } else {
+    error_message = g_strdup_printf (_("Failed to repair system: %s"), error->message);
+  }
+
+  if (NULL != error_message) {
+    pop_upgrade_set_try_again (priv, error_message);
+  }
+}
+
+static void
 cc_info_overview_panel_class_init (CcInfoOverviewPanelClass *klass)
 {
   GObjectClass *object_class = G_OBJECT_CLASS (klass);
@@ -994,21 +1310,30 @@ cc_info_overview_panel_class_init (CcInf
   gtk_widget_class_bind_template_child_private (widget_class, CcInfoOverviewPanel, firmware_upgrade_label);
   gtk_widget_class_bind_template_child_private (widget_class, CcInfoOverviewPanel, firmware_button);
 
+  // Pop!_OS OS upgrade
+  gtk_widget_class_bind_template_child_private (widget_class, CcInfoOverviewPanel, os_upgrade_frame);
+
   g_type_ensure (CC_TYPE_HOSTNAME_ENTRY);
 }
 
 static void
-on_permission_changed (GPermission *permission, GParamSpec *pspec, gpointer data) {
-  CcInfoOverviewPanelPrivate *self = data;
+about_unlock_check (CcInfoOverviewPanelPrivate *self) {
   gboolean is_allowed = g_permission_get_allowed (G_PERMISSION (self->permission));
   gtk_widget_set_sensitive (GTK_WIDGET (self->firmware_button), is_allowed);
+  gtk_widget_set_sensitive (GTK_WIDGET (self->pop_upgrade.os.button), is_allowed);
+  gtk_widget_set_sensitive (GTK_WIDGET (self->pop_upgrade.rec.button), is_allowed);
+}
+
+static void
+on_permission_changed (GPermission *permission, GParamSpec *pspec, gpointer data) {
+  about_unlock_check (data);
 }
 
 static void
 set_permissions (CcInfoOverviewPanelPrivate *self) {
   GError *error = NULL;
   self->permission = (GPermission *) polkit_permission_new_sync (INFO_PERMISSION, NULL, NULL, &error);
-  gtk_widget_set_sensitive (self->firmware_button, FALSE);
+  about_unlock_check (self);
 
   if (self->permission != NULL) {
           g_signal_connect (self->permission, "notify",
@@ -1028,6 +1353,48 @@ set_permissions (CcInfoOverviewPanelPriv
 }
 
 static void
+connect_upgrade_daemon (CcInfoOverviewPanelPrivate *priv)
+{
+  g_info ("connecting to Pop upgrade daemon");
+
+  const gchar *recovery_text = _("No recovery updates available");
+  gchar *upgrade_text = _("No upgrades available");
+  gboolean upgrade_text_copied = FALSE;
+  g_autoptr(GError) error = NULL;
+
+  gtk_widget_set_visible (priv->pop_upgrade.os.button, FALSE);
+  gtk_widget_set_visible (priv->pop_upgrade.rec.button, FALSE);
+  if (!pop_upgrade_daemon_connect (priv->upgrade_daemon, &error)) {
+    if (!pop_upgrade_daemon_release_check (priv->upgrade_daemon, &error, priv->release_check)) {
+      if (priv->release_check->available) {
+        g_info ("upgrade from %s to %s is available\n", priv->release_check->current,
+                priv->release_check->next);
+
+        recovery_text = _("Recovery update available");
+        upgrade_text = g_strdup_printf (
+          _("Upgrade from %s to %s"),
+          priv->release_check->current,
+          priv->release_check->next
+        );
+
+        upgrade_text_copied = TRUE;
+
+        gtk_button_set_label (GTK_BUTTON (priv->pop_upgrade.rec.button), _("Upgrade"));
+        gtk_button_set_label (GTK_BUTTON (priv->pop_upgrade.os.button), _("Upgrade"));
+        gtk_widget_set_visible (priv->pop_upgrade.os.button, TRUE);
+        gtk_widget_set_visible (priv->pop_upgrade.rec.button, TRUE);
+      }
+    }
+  }
+
+  gtk_label_set_text (GTK_LABEL (priv->pop_upgrade.rec.label), recovery_text);
+  gtk_label_set_text (GTK_LABEL (priv->pop_upgrade.os.label), upgrade_text);
+  if (upgrade_text_copied) {
+    g_free (upgrade_text);
+  }
+}
+
+static void
 cc_info_overview_panel_init (CcInfoOverviewPanel *self)
 {
   CcInfoOverviewPanelPrivate *priv = cc_info_overview_panel_get_instance_private (self);
@@ -1047,8 +1414,11 @@ cc_info_overview_panel_init (CcInfoOverv
   info_overview_panel_setup_virt (self);
 
   // Pop-specific details
+  priv->pop_upgrade = pop_upgrade_frame (GTK_FRAME (priv->os_upgrade_frame));
   GtkSizeGroup *button_group = gtk_size_group_new (GTK_SIZE_GROUP_HORIZONTAL);
   gtk_size_group_add_widget (button_group, priv->firmware_button);
+  gtk_size_group_add_widget (button_group, priv->pop_upgrade.os.button);
+  gtk_size_group_add_widget (button_group, priv->pop_upgrade.rec.button);
 
   set_computer_label (GTK_LABEL (priv->computer_label));
   set_model_label (GTK_LABEL (priv->model_label));
@@ -1062,9 +1432,17 @@ cc_info_overview_panel_init (CcInfoOverv
     &priv->firmware_changelog
   );
 
+  priv->upgrade_daemon = g_slice_new0 (PopUpgradeDaemon);
+  priv->release_check = g_slice_new0 (ReleaseCheck);
+
+  connect_upgrade_daemon (priv);
+
   set_permissions (priv);
 
   g_signal_connect (priv->firmware_button, "clicked", G_CALLBACK (s76_firmware_dialog), self);
+  g_signal_connect (priv->pop_upgrade.os.button, "clicked", G_CALLBACK (pop_upgrade), self);
+
+  g_object_unref (button_group);
 }
 
 GtkWidget *
Index: gnome-control-center/panels/info/info-overview.ui
===================================================================
--- gnome-control-center.orig/panels/info/info-overview.ui
+++ gnome-control-center/panels/info/info-overview.ui
@@ -366,6 +366,30 @@
           </packing>
         </child>
         <!-- Pop!_OS-specific UI widgets -->
+        <!-- OS Upgrade Option -->
+        <child>
+          <object class="GtkLabel" id="os_upgrade">
+            <property name="halign">start</property>
+            <property name="use-markup">True</property>
+            <property name="visible">True</property>
+            <property name="margin-top">12</property>
+            <property name="label" translatable="yes">&lt;b&gt;OS Upgrade &#038;amp; Refresh&lt;/b&gt;</property>
+          </object>
+          <packing>
+            <property name="expand">True</property>
+            <property name="fill">True</property>
+            <property name="position">5</property>
+          </packing>
+        </child>
+        <child>
+          <object class="GtkFrame" id="os_upgrade_frame">
+            <property name="visible">True</property>
+            <property name="can_focus">False</property>
+            <property name="label_xalign">0</property>
+            <property name="shadow_type">in</property>
+            <property name="margin_top">6</property>
+          </object>
+        </child>
         <!-- Firmware Option -->
         <child>
           <object class="GtkLabel" id="firmware_upgrade">
@@ -492,3 +516,4 @@
     </child>
   </template>
 </interface>
+
Index: gnome-control-center/panels/info/meson.build
===================================================================
--- gnome-control-center.orig/panels/info/meson.build
+++ gnome-control-center/panels/info/meson.build
@@ -54,6 +54,7 @@ sources = files(gsd_sources) + files(
   'cc-info-removable-media-panel.c',
   'dmi-info.c',
   'info-cleanup.c',
+  'pop-upgrade.c',
   's76-firmware.c',
   's76-firmware-daemon.c',
   's76-firmware-dialog.c',
@@ -127,4 +128,4 @@ script = configure_file(
 run_target(
   script_name,
   command: script
-)
+)
\ No newline at end of file
Index: gnome-control-center/panels/info/pop-upgrade.c
===================================================================
--- /dev/null
+++ gnome-control-center/panels/info/pop-upgrade.c
@@ -0,0 +1,307 @@
+#include "pop-upgrade.h"
+#include <glib/gi18n.h>
+
+const char *METHOD_FETCH_UPDATES = "FetchUpdates";
+const char *METHOD_RECOVERY_UPGRADE_FILE = "RecoveryUpgradeFile";
+const char *METHOD_RECOVERY_UPGRADE_RELEASE = "RecoveryUpgradeRelease";
+const char *METHOD_RELEASE_CHECK = "ReleaseCheck";
+const char *METHOD_RELEASE_UPGRADE = "ReleaseUpgrade";
+const char *METHOD_RELEASE_REPAIR = "ReleaseRepair";
+const char *METHOD_STATUS = "Status";
+const char *METHOD_PACKAGE_UPGRADE = "UpgradePackages";
+
+const guint8 POP_UPGRADE_RELEASE_METHOD_OFFLINE = 1;
+const guint8 POP_UPGRADE_RELEASE_METHOD_RECOVERY = 2;
+
+const gchar *POP_UPGRADE_SIGNAL_PACKAGE_FETCH_RESULT = "PackageFetchResult";
+const gchar *POP_UPGRADE_SIGNAL_PACKAGE_FETCHING = "PackageFetching";
+const gchar *POP_UPGRADE_SIGNAL_PACKAGE_FETCHED = "PackageFetched";
+const gchar *POP_UPGRADE_SIGNAL_PACKAGE_UPGRADE = "PackageUpgrade";
+const gchar *POP_UPGRADE_SIGNAL_RECOVERY_DOWNLOAD_PROGRESS = "RecoveryDownloadProgress";
+const gchar *POP_UPGRADE_SIGNAL_RECOVERY_EVENT = "RecoveryUpgradeEvent";
+const gchar *POP_UPGRADE_SIGNAL_RECOVERY_RESULT = "RecoveryUpgradeResult";
+const gchar *POP_UPGRADE_SIGNAL_RELEASE_EVENT = "ReleaseUpgradeEvent";
+const gchar *POP_UPGRADE_SIGNAL_RELEASE_RESULT = "ReleaseUpgradeResult";
+
+const guint8 POP_UPGRADE_STATUS_INACTIVE = 0;
+const guint8 POP_UPGRADE_STATUS_FETCHING_PACKAGES = 1;
+const guint8 POP_UPGRADE_STATUS_RECOVERY_UPGRADE = 2;
+const guint8 POP_UPGRADE_STATUS_RELEASE_UPGRADE = 3;
+const guint8 POP_UPGRADE_STATUS_PACKAGE_UPGRADE = 4;
+
+const gchar *POP_UPGRADE_BUS_NAME = "com.system76.PopUpgrade";
+const gchar *POP_UPGRADE_OBJECT_PATH = "/com/system76/PopUpgrade";
+const gchar *POP_UPGRADE_INTERFACE_NAME = "com.system76.PopUpgrade";
+
+const gchar *pop_upgrade_recovery_event_as_str (guint8 event) {
+  switch (event) {
+  case 1:
+    return _("Fetching recovery files");
+  case 2:
+    return _("Verifying checksums of fetched files");
+  case 3:
+    return _("Syncing recovery files with recovery partition");
+  case 4:
+    return _("Recovery partition upgrade completed");
+  case 5:
+    return _("Recovery partition upgrade failed");
+  default:
+    return NULL;
+  }
+}
+
+const gchar *pop_upgrade_release_event_as_str (guint8 event) {
+  switch (event) {
+  case 1:
+    return _("Updating package lists for the current release");
+  case 2:
+    return _("Fetching updated packages for the current release");
+  case 3:
+    return _("Upgrading packages for the current release");
+  case 4:
+    return _("Ensuring that system-critical packages are installed");
+  case 5:
+    return _("Update the source lists to the new release");
+  case 6:
+    return _("Fetching packages for the new release");
+  case 7:
+    return _("Attempting live upgrade to the new release");
+  case 8:
+    return _("Setting up the system to perform an offline upgrade on the next boot");
+  case 9:
+    return _("Setting up the recovery partition to install the new release");
+  case 10:
+    return _("The new release is ready to install");
+  case 11:
+    return _("The new release was successfully installed");
+  case 12:
+    return _("An error occurred while setting up the release upgrade");
+  default:
+    return NULL;
+  }
+}
+
+ReleaseCheck release_check_new (void) {
+    ReleaseCheck status = { NULL, NULL, FALSE };
+    return status;
+}
+
+PopUpgradeDaemonStatus pop_upgrade_daemon_status_new (void) {
+  PopUpgradeDaemonStatus status = { 0, 0 };
+  return status;
+}
+
+void release_check_free (ReleaseCheck *self) {
+    if (NULL != self) {
+        if (NULL != self->current) {
+            g_clear_pointer (&self->current, g_free);
+        }
+
+        if (NULL != self->next) {
+            g_clear_pointer (&self->next, g_free);
+        }
+    }
+}
+
+PopUpgradeDaemon pop_upgrade_daemon_new (void) {
+    PopUpgradeDaemon daemon = { NULL };
+    return daemon;
+}
+
+int pop_upgrade_daemon_connect (PopUpgradeDaemon *self, GError **error) {
+    g_info ("attempting to connect to the Pop upgrade daemon");
+
+    self->proxy = g_dbus_proxy_new_for_bus_sync (
+        G_BUS_TYPE_SYSTEM, G_DBUS_PROXY_FLAGS_NONE, NULL,
+        POP_UPGRADE_BUS_NAME, POP_UPGRADE_OBJECT_PATH,
+        POP_UPGRADE_INTERFACE_NAME, NULL, error);
+
+    if (self->proxy == NULL) {
+        g_warning ("failed to reach PopUpgrade: %s", (*error)->message);
+        return -1;
+    }
+
+    return 0;
+}
+
+int pop_upgrade_daemon_recovery_upgrade_by_release (PopUpgradeDaemon *self,
+                                                    GError **error,
+                                                    gchar *version, gchar *arch, guint8 flags) {
+    g_info ("upgrading the recovery partition by release");
+
+    GVariant *input[3];
+    input[0] = g_variant_new_string (version);
+    input[1] = g_variant_new_string (arch);
+    input[2] = g_variant_new_byte (flags);
+
+    g_autoptr(GVariant) retval = g_dbus_proxy_call_sync (self->proxy, METHOD_RECOVERY_UPGRADE_RELEASE,
+                                                         g_variant_new_tuple (input, 3),
+                                                         G_DBUS_CALL_FLAGS_NONE, -1, NULL, error);
+
+    if (*error != NULL) {
+      g_warning ("failed to call %s on PopUpgrade: %s", METHOD_RECOVERY_UPGRADE_RELEASE, (*error)->message);
+      return -1;
+    }
+
+    return 0;
+}
+
+int pop_upgrade_daemon_release_check (PopUpgradeDaemon *self, GError **error, ReleaseCheck *status) {
+    g_info ("checking for a new Pop release");
+    if (NULL == status) {
+        g_warning ("status input is null, when it should not be");
+        return -1;
+    }
+
+    g_autoptr(GVariant) retval = NULL;
+
+    retval = g_dbus_proxy_call_sync (self->proxy, METHOD_RELEASE_CHECK, NULL,
+                                     G_DBUS_CALL_FLAGS_NONE, -1, NULL, error);
+
+    if (*error != NULL) {
+        g_warning ("failed to call %s on PopUpgrade: %s", METHOD_RELEASE_CHECK, (*error)->message);
+        return -1;
+    }
+
+    const char *expected = "(ssb)";
+
+    if (retval == NULL) {
+      g_warning ("failed to call %s on PopUpgrade: expected %s, but received nothing",
+                 METHOD_STATUS, expected);
+      return -2;
+    }
+
+    g_variant_get (retval, expected, &status->current, &status->next, &status->available);
+
+    return 0;
+}
+
+int pop_upgrade_daemon_release_upgrade (PopUpgradeDaemon *self, GError **error, guint8 how,
+                                        gchar *from, gchar *to)
+{
+    g_info ("beginning release upgrade for Pop");
+
+    GVariant *input[3];
+    input[0] = g_variant_new_byte (how);
+    input[1] = g_variant_new_string (from);
+    input[2] = g_variant_new_string (to);
+
+    g_autoptr(GVariant) retval = g_dbus_proxy_call_sync (self->proxy, METHOD_RELEASE_UPGRADE,
+                                                         g_variant_new_tuple (input, 3),
+                                                         G_DBUS_CALL_FLAGS_NONE, -1, NULL, error);
+
+    if (*error != NULL) {
+        g_warning ("failed to call %s on PopUpgrade: %s", METHOD_RELEASE_UPGRADE, (*error)->message);
+        return -1;
+    }
+
+    return 0;
+}
+
+int pop_upgrade_daemon_repair (PopUpgradeDaemon *self, GError **error) {
+    g_info ("pop is checking for required system repairs");
+
+    g_autoptr(GVariant) retval = g_dbus_proxy_call_sync (self->proxy, METHOD_RELEASE_REPAIR, NULL,
+                                                         G_DBUS_CALL_FLAGS_NONE, -1, NULL, error);
+
+    if (*error != NULL) {
+        g_warning ("failed to call %s on PopUpgrade: %s", METHOD_RELEASE_REPAIR, (*error)->message);
+        return -1;
+    }
+
+    return 0;
+}
+
+int pop_upgrade_daemon_status (PopUpgradeDaemon *self, GError **error, PopUpgradeDaemonStatus *status) {
+    g_info ("checking the status of the Pop upgrade daemon");
+
+    if (NULL == self || NULL == self->proxy) {
+      g_warning ("pop_upgrade_daemon_status called with null daemon/proxy");
+      return -1;
+    }
+
+    g_autoptr(GVariant) retval = g_dbus_proxy_call_sync (self->proxy, METHOD_STATUS, NULL,
+                                                         G_DBUS_CALL_FLAGS_NONE, -1, NULL, error);
+
+    if (error != NULL && *error != NULL) {
+        g_warning ("failed to call %s on PopUpgrade: %s", METHOD_STATUS, (*error)->message);
+        return -1;
+    }
+
+    const char *expected = "(yy)";
+
+    if (retval == NULL) {
+      g_warning ("failed to call %s on PopUpgrade: expected %s, but received nothing", METHOD_STATUS, expected);
+      return -2;
+    }
+
+    status->status = g_variant_get_byte (
+      g_variant_get_child_value (retval, 0)
+    );
+
+    status->sub_status = g_variant_get_byte (
+      g_variant_get_child_value (retval, 1)
+    );
+
+    return 0;
+}
+
+static PopUpgradeOption pop_upgrade_option_new () {
+  // On click, this will initiate the pop upgrade process.
+  GtkWidget *button = gtk_button_new ();
+  gtk_label_set_use_markup (GTK_LABEL (gtk_bin_get_child (GTK_BIN (button))), TRUE);
+  gtk_widget_set_can_focus (button, TRUE);
+  gtk_widget_set_valign (button, GTK_ALIGN_CENTER);
+  gtk_style_context_add_class (gtk_widget_get_style_context (button),
+                               GTK_STYLE_CLASS_SUGGESTED_ACTION);
+
+  // The label to describe availability of an upgrade.
+  GtkWidget *label = gtk_label_new (NULL);
+  gtk_label_set_xalign (GTK_LABEL (label), 0);
+  gtk_label_set_use_underline (GTK_LABEL (label), TRUE);
+  gtk_label_set_mnemonic_widget (GTK_LABEL (label), button);
+
+  // A box for containing the label and button.
+  GtkWidget *button_box = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 12);
+  gtk_container_add (GTK_CONTAINER (button_box), label);
+  gtk_box_pack_end (GTK_BOX (button_box), button, FALSE, FALSE, FALSE);
+
+  // Displays progress of the release upgrade in progress.
+  GtkWidget *progress = gtk_progress_bar_new ();
+  gtk_progress_bar_set_ellipsize (GTK_PROGRESS_BAR (progress), PANGO_ELLIPSIZE_END);
+  gtk_progress_bar_set_show_text (GTK_PROGRESS_BAR (progress), TRUE);
+
+  // Stack for containing the button box and progress bar.
+  GtkWidget *stack = gtk_stack_new ();
+  gtk_container_add (GTK_CONTAINER (stack), button_box);
+  gtk_container_add (GTK_CONTAINER (stack), progress);
+  gtk_widget_set_margin_start (stack, 20);
+  gtk_widget_set_margin_end (stack, 20);
+  gtk_widget_set_margin_top (stack, 9);
+  gtk_widget_set_margin_bottom (stack, 9);
+  gtk_widget_set_visible (stack, TRUE);
+  gtk_widget_show_all (stack);
+  gtk_stack_set_visible_child (GTK_STACK (stack), button_box);
+
+  PopUpgradeOption option = { button, label, button_box, progress, stack };
+  return option;
+}
+
+PopUpgradeWidgets pop_upgrade_frame (GtkFrame *frame) {
+  PopUpgradeOption os = pop_upgrade_option_new ();
+  PopUpgradeOption rec = pop_upgrade_option_new ();
+
+  // Each row is added to a list, primarily used for visual style.
+  GtkWidget *list = gtk_list_box_new ();
+  gtk_widget_set_can_focus (list, TRUE);
+  gtk_list_box_set_selection_mode (GTK_LIST_BOX (list), GTK_SELECTION_NONE);
+  gtk_container_add (GTK_CONTAINER (list), os.stack);
+  gtk_container_add (GTK_CONTAINER (list), rec.stack);
+  gtk_widget_show_all (list);
+
+  // Add the list to the UI in the upgrade frame.
+  gtk_container_add (GTK_CONTAINER (frame), list);
+
+  PopUpgradeWidgets widgets = { os, rec };
+  return widgets;
+}
Index: gnome-control-center/panels/info/pop-upgrade.h
===================================================================
--- /dev/null
+++ gnome-control-center/panels/info/pop-upgrade.h
@@ -0,0 +1,124 @@
+#include <gio/gio.h>
+#include <glib.h>
+#include <gtk/gtk.h>
+#include <gmodule.h>
+
+extern const gchar *POP_UPGRADE_SIGNAL_PACKAGE_FETCH_RESULT;
+extern const gchar *POP_UPGRADE_SIGNAL_PACKAGE_FETCHING;
+extern const gchar *POP_UPGRADE_SIGNAL_PACKAGE_FETCHED;
+extern const gchar *POP_UPGRADE_SIGNAL_PACKAGE_UPGRADE;
+extern const gchar *POP_UPGRADE_SIGNAL_RECOVERY_DOWNLOAD_PROGRESS;
+extern const gchar *POP_UPGRADE_SIGNAL_RECOVERY_EVENT;
+extern const gchar *POP_UPGRADE_SIGNAL_RECOVERY_RESULT;
+extern const gchar *POP_UPGRADE_SIGNAL_RELEASE_EVENT;
+extern const gchar *POP_UPGRADE_SIGNAL_RELEASE_RESULT;
+
+extern const guint8 POP_UPGRADE_STATUS_INACTIVE;
+extern const guint8 POP_UPGRADE_STATUS_FETCHING_PACKAGES;
+extern const guint8 POP_UPGRADE_STATUS_RECOVERY_UPGRADE;
+extern const guint8 POP_UPGRADE_STATUS_RELEASE_UPGRADE;
+extern const guint8 POP_UPGRADE_STATUS_PACKAGE_UPGRADE;
+
+extern const guint8 POP_UPGRADE_RELEASE_METHOD_OFFLINE;
+extern const guint8 POP_UPGRADE_RELEASE_METHOD_RECOVERY;
+
+extern const char *POP_UPGRADE_METHOD_FETCH_UPDATES;
+extern const char *POP_UPGRADE_METHOD_RECOVERY_UPGRADE_FILE;
+extern const char *POP_UPGRADE_METHOD_RECOVERY_UPGRADE_RELEASE;
+extern const char *POP_UPGRADE_METHOD_RELEASE_CHECK;
+extern const char *POP_UPGRADE_METHOD_RELEASE_UPGRAD;
+extern const char *POP_UPGRADE_METHOD_RELEASE_REPAIR;
+extern const char *POP_UPGRADE_METHOD_STATUS;
+extern const char *POP_UPGRADE_METHOD_PACKAGE_UPGRADE;
+
+extern const gchar *POP_UPGRADE_BUS_NAME;
+extern const gchar *POP_UPGRADE_OBJECT_PATH;
+extern const gchar *POP_UPGRADE_INTERFACE_NAME;
+
+// Fetch a static string which corresponds to an event ID.
+//
+// Returns `NULL` if the event ID is out of range.
+const gchar *pop_upgrade_recovery_event_as_str (guint8 event);
+
+// Fetch a static string which corresponds to an event ID.
+//
+// Returns `NULL` if the event ID is out of range.
+const gchar *pop_upgrade_release_event_as_str (guint8 event);
+
+// When used with `pop_upgrade_daemon_release_check ()`, this will contain the
+// current release version, the next release version, and whether the next
+// release is available.
+typedef struct {
+    gchar *current;
+    gchar *next;
+    gboolean available;
+} ReleaseCheck;
+
+// Constructs a new release status struct
+ReleaseCheck release_check_new (void);
+
+// Free strings which are contained within struct.
+void release_check_free (ReleaseCheck *self);
+
+// When used ith `pop_upgrade_daemon_release_status ()`, this will contain the
+// status of the daemon.
+typedef struct {
+    guint8 status;
+    guint8 sub_status;
+} PopUpgradeDaemonStatus;
+
+// Constructs a new daemon status struct.
+PopUpgradeDaemonStatus pop_upgrade_daemon_status_new (void);
+
+// Manages a connection to Pop's upgrade daemon.
+typedef struct {
+    GDBusProxy *proxy;
+} PopUpgradeDaemon;
+
+// Creates an empty value which hasn't been connected yet.
+PopUpgradeDaemon pop_upgrade_daemon_new (void);
+
+// Attempts to connect the empty daemon value to the daemon.
+int pop_upgrade_daemon_connect (PopUpgradeDaemon *self, GError **error);
+
+// Ask the daemon to perform a recovery upgrade by the Pop release API
+int pop_upgrade_daemon_recovery_upgrade_by_release (PopUpgradeDaemon *self,
+                                                    GError **error, char *version,
+                                                    gchar *arch, guint8 flags);
+
+// Ask the daemon if a new release is available.
+int pop_upgrade_daemon_release_check (PopUpgradeDaemon *self,
+                                      GError **error, ReleaseCheck *status);
+
+/// Ask the daemon to perform a release upgrade.
+int pop_upgrade_daemon_release_upgrade(PopUpgradeDaemon *self, GError **error,
+                                       guint8 how, gchar *from, gchar *to);
+
+// Ask the daemon to request that a release upgrade is performed.
+int pop_upgrade_daemon_recovery_upgrade_by_release(PopUpgradeDaemon *self,
+                                                   GError **error,
+                                                   gchar *version, gchar *arch,
+                                                   guint8 flags);
+
+// Ask the daemon to attempt to perform any system repairs necessary.
+int pop_upgrade_daemon_repair (PopUpgradeDaemon *self, GError **error);
+
+// Ask the daemon about its current status.
+int pop_upgrade_daemon_status (PopUpgradeDaemon *self,
+                               GError **error,
+                               PopUpgradeDaemonStatus *status);
+
+typedef struct {
+    GtkWidget *button;
+    GtkWidget *label;
+    GtkWidget *button_box;
+    GtkWidget *progress;
+    GtkWidget *stack;
+} PopUpgradeOption;
+
+typedef struct {
+    PopUpgradeOption os;
+    PopUpgradeOption rec;
+} PopUpgradeWidgets;
+
+PopUpgradeWidgets pop_upgrade_frame (GtkFrame *frame);
